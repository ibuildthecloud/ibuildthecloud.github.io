
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>I build the cloud</title>
  <meta name="author" content="Darren Shepherd">

  
  <meta name="description" content="I’ve been pondering a lot lately on how the Docker ecosystem will evolve and what will be its impact on the larger infrastructure market. My current &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://blog.ibuildthecloud.com">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="I build the cloud" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=Fjalla+One" rel="stylesheet" type="text/css">
<!--- MathJax Configuration -->
<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  

</head>

<body   class="collapse-sidebar sidebar-footer" >
  <header role="banner"><hgroup>
  <h1><a href="/">I build the cloud</a></h1>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
  
  
  
  
<ul class="subscription">
  <li><a href="https://github.com/ibuildthecloud" rel="subscribe-github" title="@ibuildthecloud on GitHub">GitHub</a></li>
</ul>
  
  
  
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:blog.ibuildthecloud.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/12/evolution-of-docker-and-its-impact-on-aws/">Evolution of Docker and Its Impact on AWS</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-08-12T19:30:58-07:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>12</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>7:30 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>I’ve been pondering a lot lately on how the Docker ecosystem will evolve and what will be its impact on the larger infrastructure market.  My current day job has allowed me over the past 8 months or so to focus almost 100% of my time doing R&amp;D efforts around Docker.  As a result, I’ve had <em>a lot</em> of time to think about these things.  In my mind I see three phases in which Docker could evolve.  I don’t see it obviously trending the way I envision and the purpose of this post is to attempt to articulate the subtle differences of how I think it should change and their impact.</p>

<p>The phases I think Docker should evolve can be described as, first, Docker as an application package.  Second, Docker as a unit of orchestration, and, finally, a container cloud.  While all the hype in the media is that containers will revolutionize the cloud, based on where I see it&rsquo;s headed today, it won’t, at least not to my standards.  But it can, and that’s what I’d like to explain.  We have an incredible opportunity to completely turn the infrastructure business on its head.  So stick with me here, it gets good at the end.</p>

<h2>Docker as an Application Package</h2>

<p>The first phase is where we are today and it&rsquo;s what made Docker so popular.  The basic concept of using Docker as an application package is really to put Docker on a very similar level as rpm and deb.  To run nginx on your server today, you log in, &ldquo;apt-get install nginx&rdquo;, and then run nginx.  With Docker you can now log in and run &ldquo;docker run nginx&rdquo; or “docker run my-nodejs-app.”  Docker just becomes a more portable, easier to use rpm/deb.  That terse explanation undercuts the incredible benefits Docker brings to application packaging, deployment, and management but conceptually I think it&rsquo;s a very useful analogy.</p>

<p>At this phase of evolution the impact on the larger infrastructure space is small.  Basically, at this level of maturity you can expect Docker to become a very popular DevOps tool that has a similar impact as something like Puppet and Chef.  Puppet and Chef are great tools and do enable you to run infrastructure better, but the impact of those tools can’t be compared to something like AWS, which was an absolute game changer.</p>

<p>The talks of containers changing the world, impacting AWS stronghold on the IaaS market, and other grandiose statements will not be obtained if we don’t evolve past this simple use case.  The reason is quite basic.  If Docker remain as a means of packaging, you are running the same infrastructure you are today, but just packaging the applications in a different manner.  One argument that people make is that you’ll see a trend towards bare metal now because of Docker.  AWS enabled a paradigm shift where the unit of deployment became the server.  With Docker, you’re now able to move back up the stack and make the unit of deployment the container with even more agility than what AWS originally enabled.  This means you aren’t creating and destroying servers as often and from this perspective buying bare metal should be more attractive.</p>

<p>If you are running Docker on AWS today you are most likely using some aspect of EBS, security groups, ELB, and maybe some VPC functionality.  Therein lies the problem.  With containers you still need persistent storage and snapshots, load balancing, firewalling, and other random things.  When you move to bare metal, you need to again solve all these problems.  There&rsquo;s nothing magical about applications in Docker that would make them suddenly negate the need for something like EBS.  If your application today uses EBS, then your application in Docker will still need EBS. In practice, what I think will happen is that people will just move to larger more static instances on AWS.  To a certain degree this could help AWS because most likely the small t1, t2, m1 instances have the lowest margins.</p>

<p>Just because you can package an application in a better fashion doesn&rsquo;t mean you&rsquo;re going to change the face of the cloud.</p>

<h2>Container Cloud</h2>

<p>The next level of evolution that I think Docker should enter is that of orchestration.  Before I address what I mean by orchestration, I’m going to talk first about the last phase, which is a container cloud.  I want to talk about this first because this seems to be the logical next step for most people.  Most higher level orchestration systems are really about building a container cloud.</p>

<p>A container cloud can be described easily by saying the level of abstraction becomes the container.  In IaaS today, the level of abstraction is the virtual machine (VM).  The VM runs on some physical hardware, but as the consumer of the cloud you have no visibility or access to the physical hardware.  This is what makes the cloud a cloud.  It just runs somewhere and you shouldn’t need to concern yourself with that.  In a container cloud, similar to the VM, the container runs on something and you have no visibility/access to the underlying platform.</p>

<p>Most Docker orchestration tools I see today gravitate conceptually towards this model and maybe one day we&rsquo;ll get there.  Right now, I think there are some very practical issues in going towards this model.  The first is security, but that is less of a concern to me.  The second is a general question of usability and the appeal to the user.</p>

<p>Regarding security, as it stands today, Docker is not secure for multi-tenant environments.  This is well known.  If you wish to run multi-tenancy you have three basic options.  First option is to run a restricted set of Docker functionality.  This means not allowing root, controlling the image, and probably adding more SELinux rules.  If you wish to run a PaaS or a specific use case, these restrictions may be just fine for you.  This is essentially how Heroku can run container technology today in a multi-tenant environment.  The second option is to use physical machines or virtual machines as your security boundary.  When a customer goes to deploy a container, they buy a 1GB bucket, and that bucket ends up being a 1GB VM running somewhere.  If you&rsquo;re actually spinning up VMs, you&rsquo;re then tying a group of containers to a specific host.  I don&rsquo;t think that&rsquo;s really what the user wants.  The third option is to just ignore it and assume somebody will figure it out.  Option three is quite common.</p>

<p>Assuming security will probably be fixed or maybe the current security is sufficient for your needs, the much, much larger issue is the general usability of a container cloud.  There’s an on going debate of whether you should run SSH in your container.  The “right” answer is no, you should not.  The practical answer is often “yes, I need to.”  This basically sums up the issues of a container cloud.  A container should really be a process.  If I now have a running process somewhere in the cloud, how do I do runtime introspection of that process and provide other services like syslog, cron, monitoring, etc.</p>

<p>If you don’t give access to the host system, you need to either run all the tools in your container, or the container cloud must build a large suite of tools to provide all the runtime introspection you need.  If you run all your tools in the container, suddenly your containers are almost as fat as a VM.  This really shouldn’t be the goal of the community.</p>

<p>If you build a large collection of tools so that the users of your cloud can introspect their container, there’s a very good chance that you&rsquo;ll irritate the same audience of users that you want to attract.  It’s the same conundrum that plagues PaaS.  PaaS targets developer so that they don’t need to worry about all the underlying details of running their app in production but often by doing this they restrict what the developer can do and that makes that PaaS less attractive.  DevOps are the crowd today that loves Docker.  There’s a very good chance that the DevOps people will not like the tools provided by the “container cloud” to do introspection.  Instead they will want to just log into the host and run the tools they want.  In the end, the success of the “container cloud” will probably require extending the audience past that of the DevOps crowd.</p>

<p>It will take quite a bit of time to overcome the issue that I’ve outlined.  Assuming we do overcome them, what will be the impact on AWS and others?  I venture to say almost nothing.  You can imagine in this container cloud model you will now go to a “container cloud” provider or maybe you can run your own container cloud with some open source Docker orchestration tool.</p>

<p>The “big three” cloud providers today (AWS, GCE, Azure) will be the best suited to provide this “container cloud.”  You still need to run large quantities of physical hardware, which they already have.  Besides the basic needs of hardware, the other issue is the orchestration itself.  As I mentioned earlier, if you’re using Docker today on AWS, there’s a very good chance you&rsquo;re leveraging EBS, ELB, or VPC functionality.  Containers still need storage and networking functionality and that needs to be orchestrated in some fashion.  It’s slightly different with containers, but it still exists.  Either you run your Docker orchestration tool on AWS or you build all the orchestration of storage and networking separately.  If OpenStack has taught us anything, it is that these orchestration tools are hard to build.  AWS, GCE, Azure have a huge advantage here.  Orchestrating a VM or orchestration a container carries with it all the same basic issues and those issues they know how to deal with.  OpenStack has failed to put a dent in AWS and many can argue that it has in fact helped them (or more specifically helped GCE and Azure).  Building an open source container container platform to replace AWS in the model I’ve just described, will largely follow the same suit.  The trend I’m seeing is that these container cloud systems will in fact just be built on top of AWS.</p>

<p>At the end of the day, given what I&rsquo;m currently observing, if we do ever get to the model of a full container cloud, that cloud will probably be running on AWS.  Yet again, we fail to really impact AWS.</p>

<h2>Orchestration as a Service</h2>

<p>From my perspective, given the current trends of how I see the Docker community playing out, there will not be a mass exodus from AWS.  But there could be and let me explain how.</p>

<p>We need to find the happy compromise between the application packaging model and the container cloud; one that pulls the power away from AWS.  Let me present to you a very, very subtle change to the “container cloud” model I’ve presented thus far.  So subtle you’ll probably say, “duh, that’s what everyone is already doing.” but I’ll show you why that’s not true.  There are two key parts to this.  First, the level of abstraction is not the container, but instead, the user still has access to the underlying server albeit physical or virtual.  Second, you support a “bring your own server” model.  I think the easiest way to describe this model is to walk through a hypothetical user experience.</p>

<p>A user goes to my-awesome-container-orchestrator.com and creates an account.  They then go to AWS, SoftLayer, GCE, etc and gets a physical server or VM and registers that server with my-awesome-container-orchestrator.com.  Once that server is registered they can now deploy containers on that server, manage the docker volumes, snapshot them, back them up, move volumes around, dynamically link containers across servers, dynamically map exposed port, manage service discovery, setup security groups on the server, place containers on a private L2 with custom subnetting, add load balancing, add metrics and monitoring, add autoscaling, etc.  Since the user owns this server, they can still log in.  If they wish to run lsof or strace or install additional monitoring tools they can.</p>

<p>With this model we are basically providing Orchestration as a Service (OaaS).  Since all that containers require is Linux, you really don’t care about the underlying hardware.  Running CoreoOS on AWS, GCE, a physical server in SoftLayer, some colo, or your basement is basically the same.  With OaaS you basically create one gigantic cloud comprising all the servers in the world.  This basic idea was tried in the past with VMs, but it fell apart because there is no portability between clouds today.  Docker and Linux now make that possible.</p>

<p>If you want to run IaaS today you need physical hardware.  The basic reason being that VMs run on a hypervisor and a hypervisor needs a physical server.  (Lets ignore nested virtualization.)  Your hypervisor largely takes care of virtualizing the CPU and giving access to storage and networking.  The actual implementation of the storage and networking is provided by Linux technologies (OVS, bridging, ip/eb/arptables, dnsmasq, qcow2, vhd, iscsi, nfs, etc).  With containers you don’t need a physical server, you just need Linux.  If you replace KVM/Xen with Docker you now have the technologies you need to build a full IaaS system but with no dependency on physical hardware.  You just need Linux.</p>

<p>I don’t know if i can emphasize this point enough.  All you need is Linux and you can get Linux from anywhere.  This completely removes the stronghold AWS has on infrastructure.  It is drastically cheaper to run physical servers.  The value that AWS provides today is the additional services of EBS, ELB, VPC, etc.  With containers you still need those services.  But if Linux can provide the raw technology needed for that functionality and the orchestration of that technology is provided as a service, you are then free to chose whatever infrastructure provider you want.  There’s almost no reason to use AWS anymore.  Use some local colo company.  Then use some other colo in Singapore.  You don’t need to go with one company that has a global footprint.  Now any data center provider can compete with AWS.  Throw in a global CDN like CloudFlare and you have an incredibly complete picture at a fraction of the cost of AWS.  This approach is basically going to encourage small physical hosting companies to pop up that can operate at a lower margin than AWS can (unless they just lose money like Amazon seems to be fine with).</p>

<p>The beauty of this approach is that we decouple the physical infrastructure from the orchestration.  The model that has always been done in the past is that hardware and orchestration come together.  There is no such thing as &ldquo;OpenStack as a Service&rdquo; that is not bundled with a specific hardware offering.  The nature of VMs and IaaS makes this almost impossible.  Setting up a virtual machine cloud is very specific to the hardware environment.  With Docker and containers we move up the stack from having a hardware dependency to a Linux dependency.  This means Orchestration as a Service is actually feasible without requiring any specific hardware environment.</p>

<p>Let me explain the subtleties of this approach.  I’m guessing many people reading this might be thinking that this is what everyone is already working toward, but they aren’t.  The “container cloud” model I presented before is a full vertical stack.  Most orchestration systems being built today have the fundamental assumption that the server owner is the owner of the orchestration system.  Whoever owns the VM or server running the containers is also in charge of managing the orchestration system.  By own, I mean control.  Some systems I’ve seen allow you to enter your AWS creds, but the VM that they deploy on AWS is a black box to you.  This is problematic.  The first problem is that you are locking out the user from the host.  Going back to the issues I described about annoying DevOps people, I think the most practical solution is to give access to the host.  Second issue is if you’re giving your AWS creds to some orchestration system, that means that that system is specific to AWS or whatever cloud provider.  You need to make it such that the user can obtain the server and register it.  This opens the possibility of getting infrastructure from anywhere.</p>

<p>It’s is actually quite difficult to built an orchestration/IaaS system that assumes the host could be malicious.  There’s a lot of things to consider.</p>

<p>Next important point is that the orchestration system needs to tackle more complex storage and networking orchestration.  As I mentioned before, most Docker orchestration systems punt on networking and storage.  Why should Kubernetes provide docker volume snapshotting and backup when GCE obviously has that feature.  To achieve this model the container orchestration systems really need to greatly expand their scope.  In order to make bare metal truly feasible, we need to provide all the functionality of AWS, but purely from a Linux perspective.  This is the major difference than what I see today.  The Docker orchestration systems are very basic and for good reason.  They start with the assumption that they are running on AWS or GCE.  Obviously this puts AWS and GCE in a very good place.  Instead of cementing the future of the current cloud players I want to enable true commoditization of the cloud.  I have a hard time saying the cloud is commoditized when there are really only three players in the market and they all offer proprietary solutions.</p>

<p>I hope you understand that if we just slightly tweak our perspective we can have a huge impact.  If we continue on the path I see today, I think we will just further enable the domination of the current cloud providers.  The ideas I’ve presented are very complex to implement but this is what I do and this is what I spend most my time thinking about.  I know it can be built, no doubt.</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Darren Shepherd -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a> | Themed with <a href="https://github.com/lucaslew/whitespace">Whitespace</a></span>
</p>

</footer>
  










  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
